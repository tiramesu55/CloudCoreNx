import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import { RootState } from "../../store-platform";
import {
  getApplicationsApi,
  updateApplicationApi,
  addApplicationApi,
} from "./applicationsAPI";

interface Role{
  role:string;
  permissions: string[]
}

interface AppsGetAction{
  data : Application[];
  type: string;
}
interface IAppActionPayload {
  app: Application; 
  url: string;
  token: string;
}
interface AppAction{
  data : Application;
  type: string;
}

export interface Application{
  id?: string,
  name: string,
  appCode: string,
  roles: Role[]
}

export interface ApplicationState {
  applications: Application[];
  selectedId: number;
  status: "idle" | "loading" | "failed" | "error";
}

export const initialState: ApplicationState = {
  applications: [],
  selectedId: 0,
  status: "idle",
};

export const getApplications = createAsyncThunk<AppsGetAction,any, {state:RootState}>(
  "applications/getApplications",
  async ({ url, token } : {url: string, token: string}, {getState}) => {
    if(!token)
    return {data: null,type: "getAll"}
    const response = await getApplicationsApi(url,token);
    // The value we return becomes the `fulfilled` action payload
    return {
      data: response.data,
      type: "getAll",
    };
  }
);

export const updateApplication = createAsyncThunk<AppAction,any, {state:RootState}>(
  "applications/updateApplication",
  async (appPayload: IAppActionPayload, {getState}) => {
    const { app, url, token } = appPayload;
    // const url = state.config.baseUrl;
    if(!token)
    return {data: null,type: "updateOne"}
      const response = await updateApplicationApi(app, url,token);
      // The value we return becomes the `fulfilled` action payload
      return {
        data: response.data,
        type: "updateOne",
      };
    }

);

export const createApplication = createAsyncThunk<AppAction,any, {state:RootState}>(
  "applications/createApplication",
  async (appPayload: IAppActionPayload, {getState}) => {
    const { app, url, token } = appPayload;
    if(!token)
      return {data: null,type: "addOne"}
    const response = await addApplicationApi(app, url, token);
    // The value we return becomes the `fulfilled` action payload
    return {
      data: response.data,
      type: "addOne",
    };
  }
);

export const applicationSlice = createSlice({
  name: "applications",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
   
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getApplications.pending, (state) => {
        state.status = "loading";
      })
      .addCase(getApplications.fulfilled, (state, action) => {
        state.status = "idle";
        state.applications = action.payload.data

      })
      .addCase(getApplications.rejected, (state) => {
        state.status = "failed";
      })

      .addCase(updateApplication.fulfilled, (state, action) => {
        state.status = "idle";
        state.applications = state.applications.map((a) => {
          if (a.id === action.payload.data.id) {
            return {
              ...action.payload.data,
            };
          } else {
            return a;
          }
        });
      })
     
      .addCase(createApplication.fulfilled, (state, action) => {
        state.status = "idle";
        state.applications = [...state.applications, action.payload.data].filter(
          (item) => item.id
        );
      })

  },
});

export const selectAllApplications = (state: RootState) =>
  state.applications.applications;
export const selectSelectedId = (state: RootState) =>
  state.sites.selectedId;
export const selectAppRoles = (state: RootState) =>
{
  //get all roles associated with app
  const appRoles = state.applications.applications.map( p => ({appCode: p.appCode, name: p.name, roles: p.roles }))
  //reshape roles
  return appRoles;
}

export const applicationMapping = (state: RootState) =>
{
  //returning mapping of app codes to app name
  return new Map (state.applications.applications.map( p =>  {return [p.appCode, p.name];}));
}

export const applicationsReducer = applicationSlice.reducer;
