import { createAsyncThunk, createSlice } from "@reduxjs/toolkit";
import { RootState } from "../../store-platform";
import {
  getApplicationsApi,
  updateApplicationApi,
  addApplicationApi,
  createMaintenanceApi,
} from "./applicationsAPI";

interface Role {
  role: string;
  permissions: string[]
}

interface AppsGetAction {
  data: ApplicationRole[];
  type: string;
}
interface IAppActionPayload {
  app: ApplicationRole;
  url: string;
  token: string;
}
interface AppAction {
  data: ApplicationRole;
  type: string;
}

export interface ApplicationRole {
  id?: string,
  name: string,
  appCode: string,
  roles: Role[]
}

export interface Maintenance {
  appCode: string[],
  maintenanceStartDate: string,
  maintenanceEndDate: string,
  maintenanceDisplayStartDate: string,
  maintenanceDisplayEndDate: string,
  maintenanceReason: string,
  bypassUsers: string[],
  fullLockout: boolean;
}

interface ApplicationState {
  applications: ApplicationRole[];
  selectedId: number;
  status: "idle" | "loading" | "failed" | "error";
}

interface CreateMaintenanceAction {
  data: string;
  type: string;
}

const initialState: ApplicationState = {
  applications: [],
  selectedId: 0,
  status: "idle",
};

export const getApplications = createAsyncThunk<AppsGetAction, any, { state: RootState }>(
  "applications/getApplications",
  async ({ url, token }: { url: string, token: string }, { getState }) => {
    if (!token)
      return { data: null, type: "getAll" }
    const response = await getApplicationsApi(url, token);
    // The value we return becomes the `fulfilled` action payload
    return {
      data: response.data,
      type: "getAll",
    };
  }
);

export const updateApplication = createAsyncThunk<AppAction, any, { state: RootState }>(
  "applications/updateApplication",
  async (appPayload: IAppActionPayload, { getState }) => {
    const { app, url, token } = appPayload;
    // const url = state.config.baseUrl;
    if (!token)
      return { data: null, type: "updateOne" }
    const response = await updateApplicationApi(app, url, token);
    // The value we return becomes the `fulfilled` action payload
    return {
      data: response.data,
      type: "updateOne",
    };
  }

);

export const createApplication = createAsyncThunk<AppAction, any, { state: RootState }>(
  "applications/createApplication",
  async (appPayload: IAppActionPayload, { getState }) => {
    const { app, url, token } = appPayload;
    if (!token)
      return { data: null, type: "addOne" }
    const response = await addApplicationApi(app, url, token);
    // The value we return becomes the `fulfilled` action payload
    return {
      data: response.data,
      type: "addOne",
    };
  }
);

//Create Maintenance
export const createMaintenance = createAsyncThunk<
  CreateMaintenanceAction,
  any,
  {
    state: RootState
  }
>('createMaintenance', async ({ url, token, data }: { url: string, token: string, data: Maintenance }) => {
  if (!token) return { data: null, type: "getAllDomains" };

  const response = await createMaintenanceApi(data, url, token)

  // The value we return becomes the `fulfilled` action payload
  return {
    data: response.data,
    type: "createMaintenance",
  };
});


export const applicationSlice = createSlice({
  name: "applications",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {

  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(getApplications.pending, (state) => {
        state.status = "loading";
      })
      .addCase(getApplications.fulfilled, (state, action) => {
        state.status = "idle";
        state.applications = action.payload.data

      })
      .addCase(getApplications.rejected, (state) => {
        state.status = "failed";
      })

      .addCase(updateApplication.fulfilled, (state, action) => {
        state.status = "idle";
        state.applications = state.applications.map((a) => {
          if (a.id === action.payload.data.id) {
            return {
              ...action.payload.data,
            };
          } else {
            return a;
          }
        });
      })

      .addCase(createApplication.fulfilled, (state, action) => {
        state.status = "idle";
        state.applications = [...state.applications, action.payload.data].filter(
          (item) => item.id
        );
      })

  },
});

export const selectAllApplications = (state: RootState) =>
  state.applications.applications;
export const selectSelectedId = (state: RootState) =>
  state.sites.selectedId;
export const selectAppRoles = (state: RootState) => {
  //get all roles associated with app
  const appRoles = state.applications.applications.map(p => ({ appCode: p.appCode, name: p.name, roles: p.roles }))
  //reshape roles
  return appRoles;
}

export const applicationMapping = (state: RootState) => {
  //returning mapping of app codes to app name
  return new Map(state.applications.applications.map(p => { return [p.appCode, p.name]; }));
}

export const applicationList = (state: RootState) => {
  //returning mapping of app codes to app name
  return state.applications.applications;
}

export const permissionsList = (state: RootState) => {
  //returning all permissions for Analytics application
  const permissionSet = new Set();

  if(state.applications && state.applications.applications)
  {
    state.applications.applications.forEach(app => {
      if(app.appCode === "analytics")
      {
        app.roles.forEach( role => {
          role.permissions.forEach((permission) => permissionSet.add(permission));
        }
        )
      }
    });
  }

  return [...permissionSet] as string[];
}

export const applicationsReducer = applicationSlice.reducer;
